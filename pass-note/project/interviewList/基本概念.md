# 基本概念代码理解

> 想稍微全面理解一个知识点，可以几个博文或者几本书一块对比着看，对比着理解，这样理解更深刻，更快，更能融会贯通

- m++与++m区别
```javascript
/**
 * m++,先打印m，再执行++
 * ++m,先执行++，再打印m
 */
fnM();
function fnM(){
    var m = 10;
    console.log(m++);// 10
    console.log(m);// 11
}
```

- 闭包
> 仔细阅读博文
> [阮一峰](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)
> **闭包（closure）**是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。
> 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是**Javascript语言特有的"链式作用域"结构（chain scope）**，子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
> 在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成**"定义在一个函数内部的函数"**。
> 最大用处有两个，**一个是前面提到的可以读取函数内部的变量**，**另一个就是让这些变量的值始终保持在内存中**。
> 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，**不会在调用结束后，被垃圾回收机制（garbage collection）回收**。
> **使用闭包的注意点**
> 1）由于闭包会使得函数中的变量都被保存在内存中，**内存消耗很大，所以不能滥用闭包**，否则会造成网页的性能问题，在IE中可能导致内存泄露。**解决方法是**，在退出函数之前，将不使用的局部变量全部删除。
> 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
> 关于本博文最后的思考题
> [答案](http://www.cnblogs.com/GongQi/p/4041460.html)
> **归根结底来源于书籍上的知识点**
3. http://www.cnblogs.com/GongQi/